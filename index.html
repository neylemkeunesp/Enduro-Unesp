<!doctype html>
<html lang="pt-br">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<title>Enduro JS (homenagem)</title>
<style>
html, body {
margin: 0;
height: 100%;
background: #000;
font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
color: #fff;
overflow: hidden;
}
#game {
position: fixed;
inset: 0;
}
#ui {
position: fixed;
left: 0; right: 0; top: 0;
display: flex;
gap: 16px;
align-items: center;
padding: 10px 14px;
font-weight: 600;
text-shadow: 0 1px 3px rgba(0,0,0,.6);
pointer-events: none;
}
#ui .pill {
padding: 6px 10px;
border-radius: 999px;
background: rgba(0,0,0,.35);
font-variant-numeric: tabular-nums;
}
#title {
position: fixed;
inset: 0;
display: grid;
place-items: center;
background: radial-gradient(ellipse at center, rgba(0,0,0,.6), rgba(0,0,0,.9));
text-align: center;
}
#title .card {
max-width: 720px;
padding: 24px 20px;
border-radius: 12px;
background: rgba(0,0,0,.45);
backdrop-filter: blur(3px);
border: 1px solid rgba(255,255,255,.08);
}
#title h1 {
margin: 0 0 8px 0;
font-size: 32px;
letter-spacing: .5px;
}
#title p {
margin: 6px 0;
opacity: .9;
}
#title kbd {
background: rgba(255,255,255,.12);
border: 1px solid rgba(255,255,255,.25);
border-bottom-width: 2px;
padding: 2px 6px;
border-radius: 6px;
font-weight: 700;
}
#title .btn {
margin-top: 14px;
display: inline-block;
padding: 10px 16px;
background: #00d18f;
color: #02130c;
border-radius: 10px;
font-weight: 800;
cursor: pointer;
}
#pause {
position: fixed;
right: 10px; top: 10px;
padding: 6px 10px;
border-radius: 999px;
background: rgba(255,255,255,.1);
border: 1px solid rgba(255,255,255,.2);
cursor: pointer;
user-select: none;
}
#touch {
position: fixed; inset: 0; pointer-events: none;
}
.tbtn {
position: absolute;
bottom: 18px;
width: 80px; height: 80px;
border-radius: 50%;
background: rgba(255,255,255,.08);
border: 2px solid rgba(255,255,255,.2);
box-shadow: 0 4px 16px rgba(0,0,0,.4) inset;
pointer-events: auto;
touch-action: none;
user-select: none;
}
.tbtn:active { background: rgba(255,255,255,.16); }
#left { left: 18px; }
#right { left: 120px; }
#acc { right: 18px; }
#brk { right: 120px; }
.tlabel {
position: absolute; inset: 0; display: grid; place-items: center;
font-weight: 800; opacity: .9; text-shadow: 0 1px 2px rgba(0,0,0,.6);
}
#gameover {
position: fixed; inset: 0; display: none; place-items: center;
background: radial-gradient(ellipse at center, rgba(0,0,0,.6), rgba(0,0,0,.95));
text-align: center;
}
#gameover .card {
max-width: 640px;
padding: 24px 20px;
border-radius: 12px;
background: rgba(0,0,0,.45);
border: 1px solid rgba(255,255,255,.08);
}
a { color: #8cf; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="ui">
<div class="pill">Dia: <span id="day">1</span></div>
<div class="pill">Meta: <span id="goal">150</span></div>
<div class="pill">Ultrapassados: <span id="passed">0</span></div>
<div class="pill">Tempo: <span id="time">150.0</span>s</div>
<div class="pill">Vel: <span id="spd">0</span> km/h</div>
</div>

<div id="title">
<div class="card">
<h1>Enduro JS (homenagem)</h1>
<p>Ultrapasse a meta diária de carros para avançar de dia. Evite colisões, encare a noite e a neblina.</p>
<p>Controles: <kbd>←</kbd> <kbd>→</kbd> direção • <kbd>↑</kbd> acelera • <kbd>↓</kbd> freia • <kbd>P</kbd> pausa • <kbd>M</kbd> som</p>
<div class="btn" id="startBtn">Começar</div>
<p style="opacity:.7;margin-top:10px">Jogo independente, sem afiliação à Activision. Apenas para fins educativos e de homenagem.</p>
</div>
</div>

<div id="gameover">
<div class="card">
<h2 id="goTitle">Fim de jogo</h2>
<p id="goStats"></p>
<div class="btn" id="retryBtn">Jogar novamente</div>
</div>
</div>

<div id="pause" title="Pausar/Retomar">⏯</div>

<div id="touch">
<div class="tbtn" id="left"><div class="tlabel">◀</div></div>
<div class="tbtn" id="right"><div class="tlabel">▶</div></div>
<div class="tbtn" id="acc"><div class="tlabel">↑</div></div>
<div class="tbtn" id="brk"><div class="tlabel">↓</div></div>
</div>

<script>
(() => {
const urlParams = new URLSearchParams(window.location.search);
const debugPhase = urlParams.get('debugPhase');

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// UI refs
const uiDay = document.getElementById('day');
const uiGoal = document.getElementById('goal');
const uiPassed = document.getElementById('passed');
const uiTime = document.getElementById('time');
const uiSpd = document.getElementById('spd');
const startBtn = document.getElementById('startBtn');
const title = document.getElementById('title');
const pauseBtn = document.getElementById('pause');
const gameOver = document.getElementById('gameover');
const retryBtn = document.getElementById('retryBtn');
const goTitle = document.getElementById('goTitle');
const goStats = document.getElementById('goStats');

// Touch controls
const tLeft = document.getElementById('left');
const tRight = document.getElementById('right');
const tAcc = document.getElementById('acc');
const tBrk = document.getElementById('brk');

// Audio (mínimo, colisão)
let audioEnabled = false;
let ac, bump;
let engineOsc, engineGain;
let musicGain, musicOn = false, musicBPM = 122, musicStep = 0, musicAcc = 0, noiseBuf;

function initAudio() {
if (audioEnabled || typeof AudioContext === 'undefined') return;
try {
ac = new (window.AudioContext || window.webkitAudioContext)();
bump = ac.createOscillator();
const gain = ac.createGain();
gain.gain.value = 0;
bump.frequency.value = 90;
bump.type = 'triangle';
bump.connect(gain).connect(ac.destination);
bump.start();
// motor contínuo do jogador
engineGain = ac.createGain();
engineGain.gain.value = 0.0;
engineOsc = ac.createOscillator();
engineOsc.type = 'sawtooth';
engineOsc.frequency.value = 60;
engineOsc.connect(engineGain).connect(ac.destination);
engineOsc.start();

// música eletrônica de fundo (sequencer simples)
musicGain = ac.createGain();
musicGain.gain.value = 0.0;
musicGain.connect(ac.destination);
noiseBuf = makeNoiseBuffer();
musicOn = true;
musicStep = 0;
musicAcc = 0;
startMusic();

// função para tocar bump curto
playBump = () => {
if (!ac) return;
const g = ac.createGain();
g.gain.value = 0.0;
const o = ac.createOscillator();
o.type = 'triangle';
o.frequency.setValueAtTime(100, ac.currentTime);
o.connect(g).connect(ac.destination);
g.gain.setValueAtTime(0.0, ac.currentTime);
g.gain.linearRampToValueAtTime(0.15, ac.currentTime + 0.01);
g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime + 0.2);
o.start();
o.stop(ac.currentTime + 0.25);
};
audioEnabled = true;
} catch(e) {}
}
let playBump = () => {};
function updateEngineAudio(dt) {
  if (!audioEnabled || !ac || !engineOsc || !engineGain) return;
  const v = Math.max(0, Math.min(1, player.speed / MAX_SPEED));
  const accelBoost = input.up ? 1 : 0;
  const targetFreq = 60 + v * 260 + accelBoost * 60;
  const targetGain = (started && !paused && !gameEnded) ? (0.03 + v * 0.07 + accelBoost * 0.03) : 0.0;
  const now = ac.currentTime;
  try {
    engineOsc.frequency.setTargetAtTime(targetFreq, now, 0.06);
  } catch(e) {
    engineOsc.frequency.setValueAtTime(targetFreq, now);
  }
  try {
    engineGain.gain.setTargetAtTime(targetGain, now, 0.08);
  } catch(e) {
    engineGain.gain.setValueAtTime(targetGain, now);
  }
}

function startMusic() {
  if (!musicGain || !ac) return;
  const now = ac.currentTime;
  try {
    musicGain.gain.setTargetAtTime(0.12, now, 0.6);
  } catch(e) {
    musicGain.gain.setValueAtTime(0.12, now);
  }
}

function makeNoiseBuffer() {
  if (!ac) return null;
  const buffer = ac.createBuffer(1, ac.sampleRate, ac.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
  return buffer;
}
function noteFreq(base, semi) { return base * Math.pow(2, semi/12); }

function triggerKick(t) {
  if (!ac || !musicGain) return;
  const o = ac.createOscillator();
  o.type = 'sine';
  const g = ac.createGain();
  g.gain.setValueAtTime(0.9, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + 0.22);
  o.frequency.setValueAtTime(160, t);
  o.frequency.exponentialRampToValueAtTime(45, t + 0.22);
  o.connect(g).connect(musicGain);
  o.start(t);
  o.stop(t + 0.25);
}
function triggerSnare(t) {
  if (!ac || !musicGain || !noiseBuf) return;
  const src = ac.createBufferSource();
  src.buffer = noiseBuf;
  const bp = ac.createBiquadFilter();
  bp.type = 'bandpass';
  bp.frequency.value = 1800;
  bp.Q.value = 0.6;
  const g = ac.createGain();
  g.gain.setValueAtTime(0.28, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + 0.18);
  src.connect(bp).connect(g).connect(musicGain);
  src.start(t);
  src.stop(t + 0.2);
}
function triggerHat(t) {
  if (!ac || !musicGain || !noiseBuf) return;
  const src = ac.createBufferSource();
  src.buffer = noiseBuf;
  const hp = ac.createBiquadFilter();
  hp.type = 'highpass';
  hp.frequency.value = 6000;
  const g = ac.createGain();
  g.gain.setValueAtTime(0.12, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
  src.connect(hp).connect(g).connect(musicGain);
  src.start(t);
  src.stop(t + 0.06);
}
function triggerBass(t, semi) {
  if (!ac || !musicGain || semi == null) return;
  const o = ac.createOscillator();
  o.type = 'sawtooth';
  const lp = ac.createBiquadFilter();
  lp.type = 'lowpass';
  lp.frequency.setValueAtTime(240, t);
  lp.frequency.linearRampToValueAtTime(140, t + 0.25);
  const g = ac.createGain();
  g.gain.setValueAtTime(0.0, t);
  g.gain.linearRampToValueAtTime(0.22, t + 0.02);
  g.gain.exponentialRampToValueAtTime(0.001, t + 0.28);
  o.frequency.value = noteFreq(110, semi); // base A2
  o.connect(lp).connect(g).connect(musicGain);
  o.start(t);
  o.stop(t + 0.32);
}

function updateMusic(dt) {
  if (!audioEnabled || !ac || !musicOn || !musicGain) return;
  if (!started || paused || gameEnded) return;
  const stepDur = 60 / musicBPM / 4; // 16th
  musicAcc += dt;
  while (musicAcc >= stepDur) {
    musicAcc -= stepDur;
    const step = musicStep;
    musicStep = (musicStep + 1) & 15;
    const t = ac.currentTime + 0.03;
    if (step % 4 === 0) triggerKick(t);
    if (step === 4 || step === 12) triggerSnare(t);
    if (step % 2 === 0) triggerHat(t);
    // sequência simples de baixo (inspirada, porém original)
    const bassSeq = [0,null,null,null,7,null,null,null,0,null,null,null,5,null,null,null];
    const semi = bassSeq[step];
    if (semi !== null && semi !== undefined) triggerBass(t, semi);
  }
}

// Canvas sizing
let W = 0, H = 0, DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
function resize() {
W = window.innerWidth;
H = window.innerHeight;
DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
canvas.width = Math.floor(W * DPR);
canvas.height = Math.floor(H * DPR);
canvas.style.width = W + 'px';
canvas.style.height = H + 'px';
ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
horizon = H * 0.38;
roadBottomHalfWidth = Math.max(120, Math.min(220, W * 0.18));
buildSkyline();
}
window.addEventListener('resize', resize, {passive:true});

// Mundo e jogo
let last = 0, running = false, paused = false, started = false, gameEnded = false;

const MAX_SPEED = 280; // km/h (visual)
const ACCEL = 140; // km/h/s
const BRAKE = 280;
const FRICTION = 50;
const DAY_LENGTH = 150; // segundos por dia
const PASS_GOAL_BASE = 150;

const FAR_Z = 110; // distância "fictícia" do horizonte
const NEAR_Z = 1.0;
const CURVE_LOOKAHEAD = 2.2; // segundos à frente usados para desenhar curva no horizonte
const LANES = [-0.78, -0.26, 0.26, 0.78]; // posições relativas das faixas
const LANE_COUNT = LANES.length;
const LANE_CENTER = Math.floor(LANE_COUNT / 2);
const LANE_CHANGE_RATE = 3.6; // quão rápido o jogador converge para o centro da faixa

let horizon = 200;
let roadBottomHalfWidth = 180;

// Skyline de São Paulo
let skylineShapes = [];
let skylineFar = [];
function buildSkyline() {
skylineShapes = [];
skylineFar = [];
const baseY = horizon - 2;
// camada distante (fundo)
let x0 = -20;
while (x0 < W + 20) {
  const bw = 28 + Math.random() * 28;
  const bh = 28 + Math.random() * 70;
  skylineFar.push({ x: x0, w: bw, h: bh });
  x0 += bw + (10 + Math.random() * 16);
}
// camada principal
let x = -30;
while (x < W + 30) {
  const bw = 22 + Math.random() * 34;
  const bh = 40 + Math.random() * 110;
  const spire = Math.random() < 0.25 ? (10 + Math.random() * 34) : 0;
  skylineShapes.push({ x, w: bw, h: bh, spire });
  x += bw + (8 + Math.random() * 18);
}
}
function drawSkyline() {
const baseY = horizon - 2;
ctx.save();
// distante
const farA = 0.25 * (1 - fogLevel * 0.7);
ctx.globalAlpha = Math.max(0, farA);
ctx.fillStyle = mixColor('#0a0f1e', '#5b6b8a', ambient * 0.9);
for (const b of skylineFar) {
  ctx.fillRect(b.x, baseY - (b.h + 18), b.w, b.h);
}
ctx.globalAlpha = Math.max(0.25, 1 - fogLevel * 0.4);
// principal
ctx.fillStyle = mixColor('#0c1324', '#3a4b6b', ambient * 0.9);
for (const b of skylineShapes) {
  ctx.fillRect(b.x, baseY - b.h, b.w, b.h);
  if (b.spire > 0) {
    const sx = b.x + b.w * 0.5 - 1;
    ctx.fillRect(sx, baseY - b.h - b.spire, 2, b.spire);
  }
}
ctx.restore();
}

const input = { up:false, down:false };

const player = {
laneIdx: LANE_CENTER, // índice da faixa atual
laneX: LANES[LANE_CENTER], // posição lateral real
laneTarget: LANES[LANE_CENTER],
speed: 0, // km/h
flash: 0, // feedback de colisão
};

let curveOffset = 0; // deslocamento do centro da pista (px)
let curveTarget = 0; // alvo de curva
let curvePreview = 0; // offset projetado no horizonte
let stripeOffset = 0; // animação das faixas
let day = 1;
let passGoal = PASS_GOAL_BASE;
let passed = 0;
let score = 0;
let dayTimer = DAY_LENGTH;
let fogActive = false;
let fogTimer = 0;
let fogSchedule = []; // [ {tStart, tEnd}, ... ]
let fogLevel = 0; // 0..1 intensidade atual da neblina (com transição suave)
let fogTarget = 0; // alvo baseado no agendamento
let ambient = 1.0; // 0 noite, 1 dia
let phase = 'day'; // 'day','dusk','night','dawn'
let goalAchieved = false;

const rivals = [];

function resetFogSchedule() {
fogSchedule = [];
// Até 2 trechos de neblina por dia, 6–12s cada
const segments = Math.floor(Math.random()*2)+1;
for (let i=0;i<segments;i++){
const start = Math.random() * (DAY_LENGTH - 18);
const dur = 6 + Math.random() * 8;
fogSchedule.push({tStart:start, tEnd:start+dur});
}
}

function inFog(time) {
for (const f of fogSchedule) {
if (time >= f.tStart && time <= f.tEnd) return true;
}
return false;
}

function spawnRivals(n=3) {
rivals.length = 0;
for (let i=0;i<n;i++){
rivals.push(makeRival(true));
}
}

function makeRival(initial=false) {
const minFactor = initial ? 1.2 : 1.05;   // sempre longe do jogador
const maxFactor = initial ? 1.6 : 1.35;   // pode nascer bem além do horizonte
let z = FAR_Z * (minFactor + Math.random() * (maxFactor - minFactor));
let laneIdx = Math.floor(Math.random() * LANE_COUNT);
// tenta evitar spawn muito próximo de outros (mesmo z + mesma faixa)
for (let i=0; i<12; i++) {
  if (isSpawnClear(z, laneIdx)) break;
  z += 6; // empurra mais para longe se estiver congestionado
  laneIdx = Math.floor(Math.random() * LANE_COUNT);
}
const color = randColor();
return { z, laneIdx, color, passed:false };
}

function randColor() {
const palette = [
'#ff3b3b', '#ffd03b', '#38e25f', '#3bb2ff', '#ff7ad1', '#fff',
'#f78c1f', '#b78cff', '#7ef0ff'
];
return palette[Math.floor(Math.random()*palette.length)];
}

// evita que novos rivais nasçam muito próximos em z/faixa de outros já existentes
function isSpawnClear(z, laneIdx) {
for (const r of rivals) {
  if (Math.abs(r.z - z) < 12 && r.laneIdx === laneIdx) return false;
}
return true;
}

function resetGame() {
player.laneIdx = LANE_CENTER;
player.laneTarget = LANES[player.laneIdx];
player.laneX = player.laneTarget;
player.speed = 0;
player.flash = 0;

curveOffset = 0;
curveTarget = 0;
curvePreview = 0;
stripeOffset = 0;

day = 1;
passGoal = PASS_GOAL_BASE;
passed = 0;
score = 0;
dayTimer = DAY_LENGTH;
ambient = 1.0; phase = 'day';
resetFogSchedule();
fogActive = false;
fogTimer = 0;
goalAchieved = false;

spawnRivals();
updateUI();
}

function nextDay() {
day++;
passed = 0;
passGoal = Math.floor(PASS_GOAL_BASE * (1 + (day-1)*0.15));
dayTimer = DAY_LENGTH;
resetFogSchedule();
phase = 'day';
ambient = 1.0;
goalAchieved = false;
}

function updateUI() {
uiDay.textContent = day;
uiGoal.textContent = passGoal;
uiPassed.textContent = passed;
uiTime.textContent = dayTimer.toFixed(1);
uiSpd.textContent = Math.round(player.speed);
}

function changePlayerLane(dir) {
const nextIdx = clamp(player.laneIdx + dir, 0, LANE_COUNT - 1);
player.laneIdx = nextIdx;
player.laneTarget = LANES[nextIdx];
}

// Entrada
window.addEventListener('keydown', (e) => {
if (e.code === 'ArrowLeft' || e.code === 'KeyA') { e.preventDefault(); changePlayerLane(-1); return; }
if (e.code === 'ArrowRight' || e.code === 'KeyD') { e.preventDefault(); changePlayerLane(1); return; }
if (e.repeat) return;
if (e.code === 'ArrowUp' || e.code === 'KeyW') input.up = true;
if (e.code === 'ArrowDown' || e.code === 'KeyS') input.down = true;
if (e.code === 'KeyP') togglePause();
if (e.code === 'KeyM') {
if (!audioEnabled) initAudio();
else { audioEnabled = false; ac && ac.close && ac.close(); ac = null; }
}
});
window.addEventListener('keyup', (e) => {
if (e.code === 'ArrowUp' || e.code === 'KeyW') input.up = false;
if (e.code === 'ArrowDown' || e.code === 'KeyS') input.down = false;
});

function bindTouch(btn, on) {
const handler = (v) => (ev) => { ev.preventDefault(); on(v); };
btn.addEventListener('touchstart', handler(true), {passive:false});
btn.addEventListener('touchend', handler(false), {passive:false});
btn.addEventListener('pointerdown', handler(true));
btn.addEventListener('pointerup', handler(false));
btn.addEventListener('pointerleave', handler(false));
}
function bindLaneButton(btn, dir) {
const handle = (ev) => { ev.preventDefault(); changePlayerLane(dir); };
if (window.PointerEvent) {
  btn.addEventListener('pointerdown', handle);
} else {
  btn.addEventListener('touchstart', handle, {passive:false});
  btn.addEventListener('mousedown', handle);
}
}
bindLaneButton(tLeft, -1);
bindLaneButton(tRight, 1);
bindTouch(tAcc, v => input.up = v);
bindTouch(tBrk, v => input.down = v);

startBtn.addEventListener('click', () => {
started = true;
title.style.display = 'none';
initAudio(); // só inicializa se suportado
run();
});
pauseBtn.addEventListener('click', () => togglePause());
retryBtn.addEventListener('click', () => {
gameOver.style.display = 'none';
started = true; paused = false; gameEnded = false;
resetGame();
});
if (urlParams.has('autoStart')) {
started = true;
paused = false;
gameEnded = false;
title.style.display = 'none';
run();
}

function togglePause() {
if (!started || gameEnded) return;
paused = !paused;
// silencia o motor ao pausar e ajusta música
if (paused) {
  if (engineGain && engineGain.gain) {
    try { engineGain.gain.setTargetAtTime(0.0, ac ? ac.currentTime : 0, 0.05); }
    catch(e) { engineGain.gain.setValueAtTime(0.0, ac ? ac.currentTime : 0); }
  }
  if (musicGain && musicGain.gain) {
    try { musicGain.gain.setTargetAtTime(0.0, ac ? ac.currentTime : 0, 0.10); }
    catch(e) { musicGain.gain.setValueAtTime(0.0, ac ? ac.currentTime : 0); }
  }
}
if (!paused) {
  // retoma música com fade-in
  startMusic && startMusic();
  last = performance.now();
  run();
}
}

function run(ts) {
if (!started) return;
running = true;
last = last || performance.now();
requestAnimationFrame(loop);
}

function loop(ts) {
if (!running) return;
if (paused) { requestAnimationFrame(loop); return; }
if (!last) last = ts;
let dt = (ts - last) / 1000;
last = ts;
dt = Math.min(dt, 1/30); // clamp

update(dt);
draw();

if (!gameEnded) requestAnimationFrame(loop);
}

function update(dt) {
// Atualiza tempo do dia
dayTimer -= dt;
if (dayTimer <= 0) {
// Verifica objetivo
if (goalAchieved) {
nextDay();
} else {
endGame(false);
return;
}
}

// Ciclo dia/noite (simplificado por frações do cronômetro)
const t = 1 - (dayTimer / DAY_LENGTH);
// 0-0.15 amanhecer, 0.15-0.65 dia, 0.65-0.85 entardecer, 0.85-1 noite
let amb = 1;
if (t < 0.15) { phase = 'dawn'; amb = lerp(0.2, 1.0, t/0.15); }
else if (t < 0.65) { phase = 'day'; amb = 1.0; }
else if (t < 0.85) { phase = 'dusk'; amb = lerp(1.0, 0.25, (t-0.65)/0.2); }
else { phase = 'night'; amb = 0.15; }
if (debugPhase) {
  const forced = debugPhase.toLowerCase();
  if (forced === 'day' || forced === 'dusk' || forced === 'night' || forced === 'dawn') {
    phase = forced;
    amb = forced === 'night' ? 0.15 : (forced === 'dawn' ? 0.6 : (forced === 'dusk' ? 0.35 : 1.0));
  }
}
ambient = amb;

{
const nowT = DAY_LENGTH - dayTimer;
fogTarget = inFog(nowT) ? 1 : 0;
// transição suave da neblina
fogLevel = approach(fogLevel, fogTarget, dt * 1.5);
fogActive = fogLevel > 0.02;
}

// Curvas: ajusta alvo de curva suavemente
// Segmentos de ~6s alternando esquerda/direita leves
const curveSpeed = 20; // px/s
const trackTime = DAY_LENGTH - dayTimer;
const basePhase = trackTime*0.4 + day*1.3;
const want = Math.sin(basePhase) * W * 0.15;
curveTarget = want;
curveOffset = approach(curveOffset, curveTarget, curveSpeed * dt);
const previewPhase = (trackTime + CURVE_LOOKAHEAD)*0.4 + day*1.3;
const previewTarget = Math.sin(previewPhase) * W * 0.18;
curvePreview = approach(curvePreview, previewTarget, curveSpeed * dt * 0.6);

// Movimento e controles
let accel = 0;
if (input.up) accel += ACCEL;
if (input.down) accel -= BRAKE;
// Atrito
const sign = player.speed >= 0 ? 1 : -1;
if (!input.up && !input.down) {
const dec = Math.min(FRICTION*dt, Math.abs(player.speed));
player.speed -= dec * sign;
} else {
player.speed += accel * dt;
}
player.speed = clamp(player.speed, 0, MAX_SPEED);

// Direção por troca de faixa suave
const laneSpeed = LANE_CHANGE_RATE + (player.speed / MAX_SPEED) * 2.8;
player.laneX = approach(player.laneX, player.laneTarget, laneSpeed * dt);

// Penaliza sair da pista (grama)
// largura de pista no "pé" da tela:
const halfW = roadBottomHalfWidth;
if (Math.abs(player.laneX) > 1.0) {
player.speed -= 80 * dt;
player.speed = Math.max(player.speed, 0);
}

// Animação das faixas proporcional à velocidade
stripeOffset += (player.speed / MAX_SPEED) * 600 * dt;

// Atualiza rivais (aproximação do pseudo-3D)
const speedFactor = (player.speed / MAX_SPEED);
const zSpeed = 40 + speedFactor * 160; // quão rápido z diminui (px/s "fictício")
const visibleFar = FAR_Z * lerp(1.0, 0.35, fogLevel);
for (const r of rivals) {
r.z -= (zSpeed * dt);
if (r.z < NEAR_Z) {
// passou com sucesso (se não colidiu)
if (!r.passed) {
passed++;
score++;
r.passed = true;
updateUI();
if (!goalAchieved && passed >= passGoal) {
goalAchieved = true;
player.flash = Math.max(player.flash, 0.6);
}
}
// Respawn
const n = makeRival(false);
r.z = n.z;
r.laneIdx = n.laneIdx;
r.color = n.color;
r.passed = false;
}
}

// Colisão com rivais próximos do jogador (z menor)
// Fazemos checagem por bounding boxes projetadas
const playerScreen = projectCar(NEAR_Z + 5, player.laneX);
const pW = playerScreen.w;
const pX = playerScreen.x;
const pY = playerScreen.y;

for (const r of rivals) {
if (r.z > 25) continue; // longe suficiente
const pr = projectCar(r.z, LANES[r.laneIdx]);
if (pr.y < horizon || pr.y > H) continue;
// Sobreposição lateral e vertical (aproximação)
if (Math.abs(pr.x - pX) < (pr.w*0.45 + pW*0.45) && Math.abs(pr.y - pY) < (pr.h*0.6 + 20)) {
// colisão
collide();
// empurra rival um pouco para frente para evitar múltiplas colisões no mesmo frame
r.z += 6;
}
}

// Decaimento do flash de dano
player.flash = Math.max(0, player.flash - dt * 2);

updateEngineAudio(dt);
updateMusic(dt);
updateUI();
}

function collide() {
playBump();
player.speed *= 0.35;
player.flash = 1.0;
}

function endGame(won) {
gameEnded = true;
paused = true;
// silencia o motor ao terminar o jogo
if (engineGain && engineGain.gain) {
  try {
    engineGain.gain.setTargetAtTime(0.0, ac ? ac.currentTime : 0, 0.05);
  } catch(e) {
    engineGain.gain.setValueAtTime(0.0, ac ? ac.currentTime : 0);
  }
}
 // abaixa música ao terminar o jogo
if (musicGain && musicGain.gain) {
  try {
    musicGain.gain.setTargetAtTime(0.0, ac ? ac.currentTime : 0, 0.15);
  } catch(e) {
    musicGain.gain.setValueAtTime(0.0, ac ? ac.currentTime : 0);
  }
}
goTitle.textContent = won ? 'Parabéns! Você venceu!' : 'Fim de jogo';
goStats.innerHTML = `Dias alcançados: <b>${day}</b> • Ultrapassados no dia: <b>${passed}/${passGoal}</b> • Pontos: <b>${score}</b>`;
gameOver.style.display = 'grid';
}

// mistura offset atual com uma prévia para que a curva apareça primeiro no horizonte
function curveAt(s) {
s = clamp(s, 0, 1);
const blend = Math.pow(s, 1.4);
return lerp(curvePreview, curveOffset, blend);
}

function projectCar(z, lane) {
// converte z (1..FAR_Z) para y de tela
const y = horizon + (1 - (z / FAR_Z)) * (H - horizon);
const s = clamp((y - horizon) / (H - horizon), 0, 1); // escala 0..1
const halfWidthAtY = lerp(roadBottomHalfWidth*0.1, roadBottomHalfWidth, s);
const centerX = (W/2) + curveAt(s);
const x = centerX + (lane * halfWidthAtY);
const baseCarW = 50; // largura do carro do jogador na base
const w = clamp(baseCarW * (0.25 + s*0.9), 8, baseCarW*1.1);
const h = w * 1.4;
return { x, y, w, h };
}

function draw() {
// Céu com gradiente conforme "ambient"
const skyTop = mixColor('#0b1c46', '#73c7ff', ambient);
const skyBot = mixColor('#060a18', phase === 'dusk' ? '#ff9f40' : (phase === 'dawn' ? '#ffda7a' : '#3ea2ff'), ambient);
const grd = ctx.createLinearGradient(0,0,0,horizon);
grd.addColorStop(0, skyTop);
grd.addColorStop(1, skyBot);
ctx.fillStyle = grd;
ctx.fillRect(0,0,W,H);

// Sol/Lua estilizados (apenas um disco no horizonte)
if (phase === 'dawn' || phase === 'dusk') {
const t = (phase === 'dawn') ? (1 - (dayTimer/DAY_LENGTH)) / 0.15 : ((1 - (dayTimer/DAY_LENGTH)) - 0.65)/0.2;
const s = clamp(t, 0, 1);
ctx.globalAlpha = 0.7 * s;
ctx.fillStyle = phase === 'dawn' ? '#ffd27b' : '#ff9850';
const sunX = W*0.8;
const sunY = horizon - 40 - s*30;
ctx.beginPath();
ctx.arc(sunX, sunY, 40, 0, Math.PI*2);
ctx.fill();
ctx.globalAlpha = 1;
}

drawSkyline();
// Chão/grama
const groundGrad = ctx.createLinearGradient(0,horizon,0,H);
const grassDark = mixColor('#0b3b1b', '#1d5f2d', ambient);
const grassLight = mixColor('#0a2a15', '#2c7a3b', ambient);
groundGrad.addColorStop(0, grassLight);
groundGrad.addColorStop(1, grassDark);
ctx.fillStyle = groundGrad;
ctx.fillRect(0, horizon, W, H-horizon);

// Pista com múltiplos segmentos para desenhar curvas
const roadTopHalf = 24;
const roadBotHalf = roadBottomHalfWidth;
const roadSegments = 40;
const roadStrip = [];
for (let i=0; i<=roadSegments; i++) {
  const s = i / roadSegments;
  const y = horizon + (H - horizon) * s;
  const half = lerp(roadTopHalf, roadBotHalf, s);
  const center = (W/2) + curveAt(s);
  roadStrip.push({ s, y, half, center });
}

ctx.beginPath();
ctx.moveTo(roadStrip[0].center - roadStrip[0].half, roadStrip[0].y);
for (let i=1; i<roadStrip.length; i++) {
  const p = roadStrip[i];
  ctx.lineTo(p.center - p.half, p.y);
}
for (let i=roadStrip.length-1; i>=0; i--) {
  const p = roadStrip[i];
  ctx.lineTo(p.center + p.half, p.y);
}
ctx.closePath();
// textura do asfalto com leve ruído
const asphalt = ctx.createLinearGradient(0,horizon,0,H);
asphalt.addColorStop(0, mixColor('#2a2a2a', '#555', ambient*0.2));
asphalt.addColorStop(1, '#2a2a2a');
ctx.fillStyle = asphalt;
ctx.fill();

// Bordas da pista
ctx.save();
ctx.lineWidth = 3;
ctx.strokeStyle = '#dcdcdc';
ctx.globalAlpha = Math.max(0.35, 1 - fogLevel * 0.6);
ctx.beginPath();
ctx.moveTo(roadStrip[0].center - roadStrip[0].half, roadStrip[0].y);
for (let i=1; i<roadStrip.length; i++) {
  const p = roadStrip[i];
  ctx.lineTo(p.center - p.half, p.y);
}
ctx.stroke();
ctx.beginPath();
ctx.moveTo(roadStrip[0].center + roadStrip[0].half, roadStrip[0].y);
for (let i=1; i<roadStrip.length; i++) {
  const p = roadStrip[i];
  ctx.lineTo(p.center + p.half, p.y);
}
ctx.stroke();
ctx.restore();

// Faixa central pontilhada (dashes) – desenhar como trechos entre horizon..H
const dashCount = 22;
const dashSpacing = (H - horizon) / dashCount;
const dashLen = dashSpacing * 0.45;
for (let i=0;i<dashCount;i++){
  // animo offset
  const oy = (stripeOffset % dashSpacing);
  const y0 = horizon + i * dashSpacing + oy;
  if (y0 > horizon && y0 < H) {
    const s = clamp((y0 - horizon)/(H - horizon), 0, 1);
    const yEnd = Math.min(H, y0 + dashLen);
    const s1 = clamp((yEnd - horizon)/(H - horizon), 0, 1);
    const midS = clamp(((y0 + yEnd) * 0.5 - horizon)/(H - horizon), 0, 1);
    const cx0 = (W/2) + curveAt(s);
    const cx1 = (W/2) + curveAt(s1);
    const w = Math.max(2, 4 * midS + 2);
    // centro
    ctx.strokeStyle = mixColor('#eeeeee', '#ffffff', ambient);
    ctx.lineWidth = w;
    // atenua visibilidade da faixa com a distância e nível de neblina
    ctx.save();
    ctx.globalAlpha = Math.max(0.25, 1 - fogLevel * Math.pow(1 - midS, 1.4) * 1.05);
    ctx.beginPath();
    ctx.moveTo(cx0, y0);
    ctx.lineTo(cx1, yEnd);
    ctx.stroke();
    ctx.restore();
  }
}

 // Rivais
const visibleFar = FAR_Z * lerp(1.0, 0.85, fogLevel);
// Ordena por z desc (longe primeiro) para desenhar na ordem certa
rivals.sort((a,b) => b.z - a.z);
for (const r of rivals) {
if (r.z > visibleFar) continue; // oculto pela neblina
const pr = projectCar(r.z, LANES[r.laneIdx]);
if (pr.y < horizon || pr.y > H) continue;

 // Carro rival (um retângulo com "para-choque" simples)
ctx.save();
const fogF = fogLevel * fogAmountAtZ(r.z);
ctx.globalAlpha = Math.max(0.08, 1.0 - fogF * 0.92);
drawCar(pr.x, pr.y, pr.w, pr.h, r.color, false);
ctx.restore();
}

// Carro do jogador
const p = projectCar(NEAR_Z + 5, player.laneX);
drawCar(p.x, p.y, p.w*1.05, p.h*1.05, '#ffffff', true);

 // Efeito de farol ao entardecer (sem farol à noite)
if (phase === 'dusk') {
ctx.save();
ctx.globalCompositeOperation = 'lighter';
const headGrad = ctx.createRadialGradient(p.x, p.y, 10, p.x, p.y-40, 220);
headGrad.addColorStop(0, 'rgba(255,255,210,0.28)');
headGrad.addColorStop(1, 'rgba(255,255,210,0)');
ctx.fillStyle = headGrad;
ctx.beginPath();
ctx.ellipse(p.x, p.y-20, 160, 260, 0, 0, Math.PI*2);
ctx.fill();
ctx.restore();
}

 // Neblina (overlay)
if (fogActive) {
const fog = ctx.createLinearGradient(0,horizon,0,H);
const oTop = 0.42 * fogLevel;   // mais forte no topo (perto do horizonte)
const oMid = 0.18 * fogLevel;
const oBot = 0.04 * fogLevel;   // fraco no pé da pista
fog.addColorStop(0, `rgba(220,235,240,${oTop.toFixed(3)})`);
fog.addColorStop(0.5, `rgba(220,235,240,${oMid.toFixed(3)})`);
fog.addColorStop(1, `rgba(220,235,240,${oBot.toFixed(3)})`);
ctx.fillStyle = fog;
ctx.fillRect(0,horizon,W,H-horizon);
}

// Flash de colisão
if (player.flash > 0) {
ctx.fillStyle = `rgba(255,90,90,${0.25*player.flash})`;
ctx.fillRect(0,0,W,H);
}
drawHUD();
}

function drawCar(x, y, w, h, color, isPlayer=false) {
// Corpo
ctx.save();
ctx.translate(x, y);
// modo noturno: somente luzes acesas
const night = (phase === 'night');
if (night) {
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  const tail = isPlayer ? 'rgba(255,120,120,0.95)' : 'rgba(255,80,80,0.95)';
  ctx.fillStyle = tail;
  ctx.fillRect(-w*0.44, -h*0.15, w*0.16, h*0.08);
  ctx.fillRect(w*0.28, -h*0.15, w*0.16, h*0.08);
  ctx.fillStyle = isPlayer ? 'rgba(255,120,120,0.35)' : 'rgba(255,80,80,0.28)';
  ctx.beginPath();
  ctx.ellipse(0, -h*0.18, w*0.9, h*0.54, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
  ctx.restore();
  return;
}
// sombra
ctx.fillStyle = 'rgba(0,0,0,.25)';
ctx.fillRect(-w*0.52, -h*0.05, w*1.04, h*0.18);
// chassi
const bodyGrad = ctx.createLinearGradient(0, -h*0.82, 0, -h*0.08);
bodyGrad.addColorStop(0, mixColor(color, '#ffffff', 0.25));
bodyGrad.addColorStop(0.45, color);
bodyGrad.addColorStop(1, mixColor(color, '#000000', 0.35));
ctx.fillStyle = bodyGrad;
roundRect(-w*0.5, -h*0.8, w, h*0.82, Math.min(10, w*0.12));
ctx.fill();

 // parabrisa/capô simples
const roofColor = isPlayer ? mixColor('#002a33','#005544',0.55) : '#16181d';
const roofGrad = ctx.createLinearGradient(0, -h*0.7, 0, -h*0.32);
roofGrad.addColorStop(0, mixColor(roofColor, '#ffffff', 0.18));
roofGrad.addColorStop(1, roofColor);
ctx.fillStyle = roofGrad;
roundRect(-w*0.36, -h*0.68, w*0.72, h*0.34, 6);
ctx.fill();
// faixa central leve
ctx.fillStyle = 'rgba(255,255,255,0.18)';
ctx.fillRect(-w*0.05, -h*0.78, w*0.10, h*0.70);

 // Marca "Unesp" no carro do jogador
if (isPlayer) {
  ctx.save();
  ctx.fillStyle = '#004aad';
  ctx.strokeStyle = 'rgba(0,0,0,0.55)';
  ctx.lineWidth = Math.max(1, w * 0.035);
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = `bold ${Math.max(10, Math.floor(w * 0.20))}px Arial`;
  // posiciona na parte de baixo do carro (acima dos faróis)
  const yLabel = -h * 0.18;
  ctx.strokeText('Unesp', 0, yLabel);
  ctx.fillText('Unesp', 0, yLabel);
  ctx.restore();
}

// faróis traseiros dianteiros estilizados
ctx.fillStyle = '#f4f4f4';
roundRect(-w*0.46, -h*0.76, w*0.22, h*0.12, 4);
roundRect(w*0.24, -h*0.76, w*0.22, h*0.12, 4);
ctx.fillStyle = isPlayer ? '#fff6c4' : '#ffe5a8';
roundRect(-w*0.44, -h*0.73, w*0.18, h*0.08, 4);
roundRect(w*0.26, -h*0.73, w*0.18, h*0.08, 4);
ctx.fillStyle = mixColor(color, '#ff5555', 0.65);
roundRect(-w*0.44, -h*0.12, w*0.18, h*0.10, 4);
roundRect(w*0.26, -h*0.12, w*0.18, h*0.10, 4);

// rodas
const wheelGrad = ctx.createLinearGradient(-w*0.55, 0, -w*0.43, 0);
wheelGrad.addColorStop(0, '#080808');
wheelGrad.addColorStop(1, '#1c1c1c');
ctx.fillStyle = wheelGrad;
ctx.fillRect(-w*0.55, -h*0.6, w*0.12, h*0.28);
const wheelGradR = ctx.createLinearGradient(w*0.43, 0, w*0.55, 0);
wheelGradR.addColorStop(0, '#1c1c1c');
wheelGradR.addColorStop(1, '#080808');
ctx.fillStyle = wheelGradR;
ctx.fillRect(w*0.43, -h*0.6, w*0.12, h*0.28);

ctx.restore();
}

function drawHUD() {
const panelW = Math.min(240, Math.max(200, W * 0.28));
const panelH = 120;
const x = 12;
const y = H - panelH - 12;
const pad = 10;

ctx.save();
// painel
ctx.globalAlpha = 1;
ctx.fillStyle = 'rgba(0,0,0,0.45)';
roundRect(x, y, panelW, panelH, 10);
ctx.fill();
ctx.strokeStyle = 'rgba(255,255,255,0.15)';
ctx.stroke();

// textos
ctx.fillStyle = '#ffffff';
ctx.font = 'bold 14px Arial';
let yy = y + pad + 12;
ctx.fillText(`Vel: ${Math.round(player.speed)} km/h`, x + pad, yy);
yy += 18;
ctx.fillText(`Pontos: ${score}`, x + pad, yy);
yy += 18;
ctx.fillText(`Dia: ${day} • Meta: ${passGoal}`, x + pad, yy);
yy += 18;
ctx.fillText(`Tempo: ${dayTimer.toFixed(1)}s`, x + pad, yy);

// barras
const barW = panelW - pad*2;
// progresso meta
const gBarY = y + panelH - pad - 22;
ctx.fillStyle = 'rgba(255,255,255,0.2)';
ctx.fillRect(x + pad, gBarY, barW, 6);
const g = clamp(passed / Math.max(1, passGoal), 0, 1);
ctx.fillStyle = '#ffd03b';
ctx.fillRect(x + pad, gBarY, barW * g, 6);

// velocidade
const sBarY = gBarY + 10;
ctx.fillStyle = 'rgba(255,255,255,0.2)';
ctx.fillRect(x + pad, sBarY, barW, 8);
const t = clamp(player.speed / MAX_SPEED, 0, 1);
const grad = ctx.createLinearGradient(x + pad, 0, x + pad + barW, 0);
grad.addColorStop(0, '#00d18f');
grad.addColorStop(1, '#2affea');
ctx.fillStyle = grad;
ctx.fillRect(x + pad, sBarY, barW * t, 8);

ctx.restore();
}

function roundRect(x,y,w,h,r) {
ctx.beginPath();
ctx.moveTo(x+r,y);
ctx.arcTo(x+w,y,x+w,y+h,r);
ctx.arcTo(x+w,y+h,x,y+h,r);
ctx.arcTo(x,y+h,x,y,r);
ctx.arcTo(x,y,x+w,y,r);
ctx.closePath();
}

// Utils
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function lerp(a,b,t){ return a + (b-a)*t; }
function approach(v, target, delta){ if (v < target) return Math.min(target, v+delta); else return Math.max(target, v-delta); }
function mixColor(a,b,t){
const ca = hexToRgb(a), cb = hexToRgb(b);
const r = Math.round(lerp(ca.r, cb.r, t));
const g = Math.round(lerp(ca.g, cb.g, t));
const bl = Math.round(lerp(ca.b, cb.b, t));
return `rgb(${r},${g},${bl})`;
}
function hexToRgb(hex){
const h = hex.replace('#','');
const n = parseInt(h,16);
if (h.length === 6) return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
if (h.length === 3) {
const r = parseInt(h[0]+h[0],16), g=parseInt(h[1]+h[1],16), b=parseInt(h[2]+h[2],16);
return { r,g,b };
}
return { r:255,g:255,b:255 };
}

// Atenuação de neblina por distância (0 perto -> 1 longe)
function fogAmountAtZ(z){
const d = clamp((z - NEAR_Z) / (FAR_Z - NEAR_Z), 0, 1);
return d * d; // curva quadrática para transição mais suave
}

// Inicializa
resize();
resetGame();

// Se o usuário não clicar em "Começar", nada roda (boa prática para áudio em mobile)
})();
</script>
</body>
</html>
